1. 根对象是什么？
	根对象又叫做 根集合，是垃圾回收器在标记过程时最先检查的对象包括：
	- 全局变量
	- 执行栈：每个 goroutine 都有自己的执行栈，这些执行栈上包含栈上的变量以及指向分配的堆内存区块的指针。
	- 寄存器：寄存器的值可能表示指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块
2. 三色抽象及其不变性
	三色抽象只是一种描述追踪式回收器的方法，在实践中并没有实际含义。也就是说谈及三色标记法时，通常指标记清扫的垃圾回收。
	- 白色对象（可能死亡）：未被回收器扫描到的对象，在回收开始阶段所有的对象均为白色对象，当回收结束后，白色对象均不可达；
	- 灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象；
	- 黑色对象（确定存活）：已被回收器扫描的对象，其中所有字段都已经被扫描。
	当垃圾回收开始时，只有白色对象。随着标记过程开始进行时，灰色对象开始出现（着色），这时候波面便开始扩大。当一个对象的所有子节点均完成扫描时，会被着色为黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象为可达对象，即存活；而白色对象为不可达对象，即死亡。
4. 弱三色不变性
	垃圾回收器的正确性体现在：不应处想对象的丢失，也不应错误的回收不需要回收的对象。
	当一下两个条件同时满足时，会破坏垃圾回收器的正确性：
	- 赋值器修改对象图，导致某一黑色对象引用白色对象；
	- 从灰色对象出发，到达白色对象的，未经访问过的路径被赋值器破坏。
	只要能够避免其中任何一个条件，则不会出现对象丢失的情况
	-   当满足原有的三色不变性定义的情况称为强三色不变性
	-   当赋值器令黑色对象引用白色对象时的情况称为弱三色不变性
5. 灰色赋值器的 Dijkstra 插入屏障
	核心思想：把赋值器对已存活对象的集合的插入行为通知给回收器，进而产生可能需要额外重新扫描的对象。
	如果某一对象的引用被插入到已经被标记为黑色的对象中，插入屏障会保守的将其作为存活的非白色对象，来满足强三色不变性。
6. 插入屏障的缺点
	 1. 由于插入屏障的保守性，在一次回收的过程中，可能会产生一部分被染黑的垃圾对象，这些对象只能在下一次垃圾回收的过程中被回收。
	 2. 在标记过程中，每次指针的赋值操作都会引用插入屏障，会增加性能开销，所以只在堆空间的指针赋值操作开启写屏障，栈上的指针赋值操作不开启，当栈上有有指针的写操作时，将栈标记为灰色，在标记结束阶段会 STW 来扫描栈空间。
7. 黑色赋值器的 Yuasa 的删除屏障
	核心思想：当赋值器从灰色或白色对象中删除白色指针的时候，通过写屏障将这一行为通知给并发执行的回收器。
	被删除的对象，如果自身为灰色或者白色，那么就被标记为灰色，满足若三色不变式。
8. 删除屏障的缺点
	回收精度低，一个对象即使被删除了最后一个指向他的指针，这个对象依旧可以存活在这一轮，在下一轮GC中被清理掉。
	GC开始时STW扫描堆栈来记录初始快照
9. 混合写屏障
	1. GC 开始时，将栈上的对象全部标记为黑色
	2. GC 期间，所有在栈上创建的新对象，均标记为黑色
	3. 被删除的对象标记为灰色
	4. 被添加的对象也标记为灰色
10. GC 的触发时机
	- gcTriggerHeap：当所分配的堆的大小达到阈值时，将会触发
	- gcTriggerTime：当距离上一次 GC 周期的时间超过一定时间，将会触发，默认是 2 分钟
	- gcTriggerCycle：如果当前没有开启垃圾收集，则触发新的循环
	- 手动触发，runtime.GC 方法
	